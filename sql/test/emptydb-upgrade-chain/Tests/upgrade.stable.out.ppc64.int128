Running database upgrade commands to update system tables.

Running database upgrade commands:
create function sys.generate_series(first hugeint, "limit" hugeint)
returns table (value hugeint)
external name generator.series;
create function sys.generate_series(first hugeint, "limit" hugeint, stepsize hugeint)
returns table (value hugeint)
external name generator.series;
create aggregate stddev_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."stdev";
GRANT EXECUTE ON AGGREGATE stddev_samp(HUGEINT) TO PUBLIC;
create window stddev_samp(val HUGEINT) returns DOUBLE
 external name "sql"."stdev";
GRANT EXECUTE ON WINDOW stddev_samp(HUGEINT) TO PUBLIC;
create aggregate stddev_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."stdevp";
GRANT EXECUTE ON AGGREGATE stddev_pop(HUGEINT) TO PUBLIC;
create window stddev_pop(val HUGEINT) returns DOUBLE
 external name "sql"."stdevp";
GRANT EXECUTE ON WINDOW stddev_pop(HUGEINT) TO PUBLIC;
create aggregate var_samp(val HUGEINT) returns DOUBLE
 external name "aggr"."variance";
GRANT EXECUTE ON AGGREGATE var_samp(HUGEINT) TO PUBLIC;
create window var_samp(val HUGEINT) returns DOUBLE
 external name "sql"."variance";
GRANT EXECUTE ON WINDOW var_samp(HUGEINT) TO PUBLIC;
create aggregate covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariance";
GRANT EXECUTE ON AGGREGATE covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_samp(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariance";
GRANT EXECUTE ON WINDOW covar_samp(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate var_pop(val HUGEINT) returns DOUBLE
 external name "aggr"."variancep";
GRANT EXECUTE ON AGGREGATE var_pop(HUGEINT) TO PUBLIC;
create window var_pop(val HUGEINT) returns DOUBLE
 external name "sql"."variancep";
GRANT EXECUTE ON WINDOW var_pop(HUGEINT) TO PUBLIC;
create aggregate covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."covariancep";
GRANT EXECUTE ON AGGREGATE covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create window covar_pop(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."covariancep";
GRANT EXECUTE ON WINDOW covar_pop(HUGEINT, HUGEINT) TO PUBLIC;
create aggregate median(val HUGEINT) returns HUGEINT
 external name "aggr"."median";
GRANT EXECUTE ON AGGREGATE median(HUGEINT) TO PUBLIC;
create aggregate quantile(val HUGEINT, q DOUBLE) returns HUGEINT
 external name "aggr"."quantile";
GRANT EXECUTE ON AGGREGATE quantile(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate median_avg(val HUGEINT) returns DOUBLE
 external name "aggr"."median_avg";
GRANT EXECUTE ON AGGREGATE median_avg(HUGEINT) TO PUBLIC;
create aggregate quantile_avg(val HUGEINT, q DOUBLE) returns DOUBLE
 external name "aggr"."quantile_avg";
GRANT EXECUTE ON AGGREGATE quantile_avg(HUGEINT, DOUBLE) TO PUBLIC;
create aggregate corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "aggr"."corr";
GRANT EXECUTE ON AGGREGATE corr(HUGEINT, HUGEINT) TO PUBLIC;
create window corr(e1 HUGEINT, e2 HUGEINT) returns DOUBLE
 external name "sql"."corr";
GRANT EXECUTE ON WINDOW corr(HUGEINT, HUGEINT) TO PUBLIC;
create function json.filter(js json, name hugeint)
returns json external name json.filter;
GRANT EXECUTE ON FUNCTION json.filter(json, hugeint) TO PUBLIC;
update sys.functions set system = true where system <> true and name in ('generate_series') and schema_id = (select id from sys.schemas where name = 'sys') and type = 5;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'median', 'median_avg', 'quantile', 'quantile_avg', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 3;
update sys.functions set system = true where system <> true and name in ('stddev_samp', 'stddev_pop', 'var_samp', 'covar_samp', 'var_pop', 'covar_pop', 'corr') and schema_id = (select id from sys.schemas where name = 'sys') and type = 6;
update sys.functions set system = true where system <> true and name = 'filter' and schema_id = (select id from sys.schemas where name = 'json') and type = 1;

Running database upgrade commands:
drop procedure if exists SHPattach(string) cascade;
drop procedure if exists SHPload(integer) cascade;
drop procedure if exists SHPload(integer, geometry) cascade;

Running database upgrade commands:
create procedure SHPLoad(fname string, schemaname string, tablename string) external name shp.load;
create procedure SHPLoad(fname string, tablename string) external name shp.load;
update sys.functions set system = true where schema_id = 2000 and name in ('shpload');
Running database upgrade commands:
drop function if exists sys.st_intersects(geometry, geometry) cascade;
drop function if exists sys.st_dwithin(geometry, geometry, double) cascade;
drop view if exists sys.geometry_columns cascade;
drop function if exists sys.st_collect(geometry, geometry) cascade;
drop aggregate if exists sys.st_collect(geometry) cascade;
drop aggregate if exists sys.st_makeline(geometry) cascade;
create view sys.geometry_columns as
 select cast(null as varchar(1)) as f_table_catalog,
  s.name as f_table_schema,
  t.name as f_table_name,
  c.name as f_geometry_column,
  cast(has_z(c.type_digits) + has_m(c.type_digits) +2 as integer) as coord_dimension,
  c.type_scale as srid,
  get_type(c.type_digits, 0) as geometry_type
 from sys.columns c, sys.tables t, sys.schemas s
 where c.table_id = t.id and t.schema_id = s.id
  and c.type in (select sqlname from sys.types where systemname in ('wkb', 'wkba'));
GRANT SELECT ON sys.geometry_columns TO PUBLIC;
CREATE FUNCTION ST_Collect(geom1 Geometry, geom2 Geometry) RETURNS Geometry EXTERNAL NAME geom."Collect";
GRANT EXECUTE ON FUNCTION ST_Collect(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_Collect(geom Geometry) RETURNS Geometry external name aggr."Collect";
GRANT EXECUTE ON AGGREGATE ST_Collect(Geometry) TO PUBLIC;
CREATE FUNCTION ST_DistanceGeographic(geom1 Geometry, geom2 Geometry) RETURNS double EXTERNAL NAME geom."DistanceGeographic";
GRANT EXECUTE ON FUNCTION ST_DistanceGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithinGeographic(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithinGeographic";
GRANT EXECUTE ON FILTER ST_DWithinGeographic(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME rtree."DWithin";
GRANT EXECUTE ON FILTER ST_DWithin(Geometry, Geometry, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_DWithin_NoIndex(geom1 Geometry, geom2 Geometry, distance double) EXTERNAL NAME geom."DWithin_noindex";
GRANT EXECUTE ON FILTER ST_DWithin_NoIndex(Geometry, Geometry, double) TO PUBLIC;
CREATE FUNCTION ST_DWithin2(geom1 Geometry, geom2 Geometry, bbox1 mbr, bbox2 mbr, dst double) RETURNS boolean EXTERNAL NAME geom."DWithin2";
GRANT EXECUTE ON FUNCTION ST_DWithin2(Geometry, Geometry, mbr, mbr, double) TO PUBLIC;
CREATE FILTER FUNCTION ST_IntersectsGeographic(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."IntersectsGeographic";
GRANT EXECUTE ON FILTER ST_IntersectsGeographic(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects(geom1 Geometry, geom2 Geometry) EXTERNAL NAME rtree."Intersects";
GRANT EXECUTE ON FILTER ST_Intersects(Geometry, Geometry) TO PUBLIC;
CREATE FILTER FUNCTION ST_Intersects_NoIndex(geom1 Geometry, geom2 Geometry) EXTERNAL NAME geom."Intersects_noindex";
GRANT EXECUTE ON FILTER ST_Intersects_NoIndex(Geometry, Geometry) TO PUBLIC;
CREATE AGGREGATE ST_MakeLine(geom Geometry) RETURNS Geometry external name aggr."MakeLine";
GRANT EXECUTE ON AGGREGATE ST_MakeLine(Geometry) TO PUBLIC;
update sys.functions set system = true where system <> true and schema_id = 2000 and name in ('st_collect', 'st_distancegeographic', 'st_dwithingeographic', 'st_dwithin', 'st_dwithin_noindex', 'st_dwithin2', 'st_intersectsgeographic', 'st_intersects', 'st_intersects_noindex', 'st_makeline');
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'geometry_columns';

Running database upgrade commands:
drop function sys.similarity(string, string) cascade;

Running database upgrade commands:
create view sys.describe_accessible_tables as
 select
 schemas.name as schema,
 tables.name as table,
 table_types.table_type_name as table_type,
 privilege_codes.privilege_code_name as privs,
 privileges.privileges as privs_code
 from privileges
 join sys.roles
 on privileges.auth_id = roles.id
 join sys.tables
 on privileges.obj_id = tables.id
 join sys.table_types
 on tables.type = table_types.table_type_id
 join sys.schemas
 on tables.schema_id = schemas.id
 join sys.privilege_codes
 on privileges.privileges = privilege_codes.privilege_code_id
 where roles.name = current_role;
GRANT SELECT ON sys.describe_accessible_tables TO PUBLIC;
update sys._tables set system = true where system <> true and schema_id = 2000 and name = 'describe_accessible_tables';

