mal_scenario.c:runScenarioBody(cleint c, int once)
	In this functions where going to loop multiple times over a couple of phases:
	initclient, reader, parser, optimize, scheduler, engine, repeat...

sql_scenario.c:SQLparser (first run)
	We start with a Client c
	we instantiate local references to the client's in- and outputstream (in = c->fdin, out = c->fdout)

	c has sqlcontext of type backend (be = c->sqlcontext)
	c has a malblock (c->curprg->def)
	
	we define a local reference m to the mvc(whatever that is) of the backend (sqlcontext) of the client
	and later on we intialize it with a sqlallocator(whatever that is) (m->sa = sa_create())
	be-> language is set to 'X'
	and it seems that the first string in the inputstream in contains "Xreply_size 100\n"
	mvc->reply_size is initialized with this value.
	then we	exit and return to the loop in mal_scenario.
	


sql_scenario.c:SQLparser (second run)
	In the second run the input stream is "Xreply_size -1\n"
	
	
sql_scenario.c:SQLparser (third run)
	In the third run the input stream the language is 'S'
	we start a sqltransaction (SQLtrans(m);)
	we assign a sql_allocator (m->sa = sa_create();)
	we finally are going to parse the actual query (if( (err = sqlparse(m)) || ) this is the yacc generated c code
sqlparse:
	This part is done by the yacc created parser based on sql_parser.y grammar.
	specificallt for keyword 'IN' (in_predicate : pred_exp sqlIN '(' value_commalist ')')
		we initialize a list l;
		we associate symbol pred_expr(which seems to be the name of the column)  with the list value_commalist to l
		we create and return a symbol representing a tuple of the form ("SQL_IN", l);
	delete seems to be done in the delete_stmt: sqlDELETE FROM qname opt_where_clause(pred_exp)
		we initialize a dlist l;
		we append the name of the relation and the where_clause (pred_exp with in) to l;
		and we create and return a symbol from tuple (SQL_DELETE, l), i.e. we get something like
		SQL_DELETE(symbol)
			- qname(a list because it can concern multiple relations)
			- pred_exp()

	in symbol_create_list (sql_symbol.c)
		we allocate a symbol s
		initialize s with the token(id)
		we add the list field (data)  of type dlist to s (s->data.lval = data)

	dlist_append_list
		creates a dnode of type list where dnode has a union type member and sets a pointer to the data(of type dlist) to be appended
		that dnode is then added to dlist in a linked list way.
	Samething for dlist_append_symbol Only the type is now symbol.
sql_symbol2relation:
	rel_semantic:
		We desent through rel_updates -> delete_table
			we bind a table (t = mvc_bind_table(sql, schema, tname);)
			here is where we determin that opt_where is a value list (r = rel_logical_exp(sql, r, opt_where, sql_where);)
			It then basically transforms a rel_logical_exp to an exp_in expression with more semantics (e = exp_in(sql->sa, l, nvals, sc->token==SQL_NOT_IN?cmp_notin:cmp_in);)
			we then going to take the TID column (internal table (primary) key column or something like that) (exp_column(sql->sa, rel_name(r), TID, sql_bind_localtype("oid"), CARD_MULTI, 0, 1);)
			we make a projection on the relation using only the above column (internally that means that to relation r, we just add an expression (the TID column))
			we return this prepared relation r all the way bacj to super caller sql_symbol2relation (r = rel_semantic(c, sym);)
	rel_optimizer:
		This is where the sql statement is being fixed up if necessary. But it is not where we want to perform our optimization.
backend_dumpproc:
	Here is where we are going to build the MAL. we desent through backend_dumpstmt -> sql_relation2stmt ->_rel_bin ->output_rel_bin->_subrel_bin->subrel_bin->rel2bin_delete
	rel2bin_delete(backend *be, sql_rel *rel, list *refs):
		rows = subrel_bin(be, rel->r, refs): First create deletes relation:
			rel2bin_project(be, rel->r, refs, NULL):
				sub = subrel_bin(be, rel->r->l, refs):
					rel2bin_select(be, rel->r->l, refs):
						sub = subrel_bin(be, rel->r->l->l, refs):
							rel2bin_basetable(be, rel->r->l->l) (This is the spot where no sub relations can be brought to the table)
								dels = stmt_tid(rel->r->l<table>) (Adds a sql.tid mal instruction to mb) (dels is a unfortunate name, tids would be better)
								s = stmt_col(be, find_sql_column(t, rel->exps->h->data->r<apparently given column name>), dels);
								(happens in a for loop since there can be multiple columns in a table;)
								list_append(l, s); (add s to a previously initialized list l;)
								return stmt_list(be, l);
						s = exp_bin(be, rel->r->l->exps->h->data, sub, NULL...)
							return handle_in_exps(be, rel->r->l->exps->h->data->l, list *nl = rel->r->l->exps->h->data->r, sub, NULL..., in = 1, 0)
								c = exp_bin(be, rel->r->l->exps->h->data, sub, NULL...);
										s = bin_find_column(be, sub, rel->r->l->exps->h->data->l->l("table1"), rel->r->l->exps->h->data->l->r"id");
										(the above function seems to return the one col_stmt that matches the one used in the "in" statement)
								start for(node n = nl->h; n; n = n->next):
									stmt i = exp_bin(be, n->data, sub, NULL...)
										l = exp_bin(be, n->data->l, sub, NUL...)
											s = stmt_varnr(be, n->data->l->flag, n->data->l->tpe);
												InstrPtr q = newAssignment(be->mb); (just pushes an instruction)
												q = pushArgument(be->mb, q, be->mvc->args[n->data->l->flag]->varid);
												stmt s = stmt_create(be->mvc->sa, st_var);
												s->op1 = NULL, s->op4.typeval = n->data->l->tpe, s->flag = nr, s->q = q, s->nr = q->argv[0];
												return s;
											return s;
										s = stmt_convert(be, l, n->data->r->h->data, n->data->r->h->next->data);
											q = newStmt(be->mb, calcRef, convert = n->data->r->h->next->data(sql_subtype)->type->base.name = "int")
											q = pushArgument(be->mb, q, l->nr)
											stmt *s = stmt_create(be->mvc->sa, st_convert)
											s->op1 = l, s->nrcols = l->nrcols, s->key = l->key, s->aggr = l aggr, s->nr = getDestVar(q), s->q = q
											return s;
										return s;
									i = stmt_uselect(be, c, i, cmp, NULL, 0)
										q = newStmt(be->mb, AlgebraRef, ThetaselectRef)
										q = pushArgument(mb, q, c->nr); // column "id"
										q = pushArgument(mb, q, i->nr); // element from value list
										q = pushStr(mb, q, "==");
										stmt s = stmt_create(be->mvc->sa, st_uselect);
										s->op1 = c->nr, s->op2 = i->nr, s>op3 = NULL, s->flag == cmp, s->nrcols = 2, s->nr = q->argv[0], s->q = q;
										return s;
									if (s) // basically you creating unions out of the results from the theta_select
										s = stmt_tunion(be, s, i);
											q = newStmt(be->mb, batRef, mergecandRef); //via dump_2
											q = pushArgument(be->mb, q, s->nr); //via dump_2
											q = pushArgument(be->mb, q, i->nr); //via dump_2
											stmt *r = stmt_create(be->mvc->sa, st_tunion);
											r->op1 = s, r->op2 = i, r->nrcols = s->nrcols, r->key = s->key, r->aggr = s->aggr, r->nr=q->argv[0], s->q= q
											return s;
									else
										s = i;
								return s; // basically the result of the last union of previous theta-selects and unions.
						l = sa_list(be->mvc->sa);
						col1 = stmt_project(be, s, sub->op4.lval->h->data<="id">); // This actually happens in a for loop
							q = stmt_project_join(be, s, sub->op4.lval->h->data, NULL):
								q = newStmt(mb, algebraRef, projectionRef);
								q = pushArgument(mb, q, s->nr);
								q = pushArgument(mb, q, sub->op4.lval->h->nr);
							stmt *s = stmt_create(be->mvc->sa, st_join);

							s->op1 = s;
							s->op2 = sub->op4.lval->h->data;
							s->flag = cmp_project;
							s->key = 0;
							s->nrcols = 2;
							s->nr = getDestVar(q);
							s->q = q;
							return s;
								
						col2 = stmt_project(be, s, sub->op4.lval->h->next->data<="%TID%">); // This actually happens in a for loop
							// like previous stmt_project
						list_append(l, col1<="id">); // This actually happens in a for loop
						list_append(l, col2<="%TID%">); // This actually happens in a for loop
						return stmt_list(be, l);
				pl = sa_list(be->mvc->sa)
				psub = stmt_list(be, pl);
				stmt s = exp_bin(be, rel->exps->h->data, sub, psub, NULL...); 
					s = bin_find_column(be, sub, rel->exps->h->data->l, rel->exps->h->data->r); // returns a join_statement with cname %TID%
					return s;
				list_append(pl, s);
				stmt_set_nrcols(psub) // only works for list_statement sets it to the largest nrcols of its element.
				return psub;
		(back to rel2bin_delete repeat for clarity rows = psub)
		rows = rows->op4.lval->h->data; // because rows is a list (psub)
		t = rel->l->r; // because rel->l is of type op_basetable
		stdelete = sql_delete(be, t, rows);
			list *l = sa_list(be->mvc->sa);
			v = rows;
			s = stmt_delete(be, t, rows);
				q = newStmt(be->mb, sqlRef, deleteRef);
				q = pushArgument(mb, q, be->mvc_var);
				getArg(q, 0) = be->mvc_var = newTmpVariable(be->mb, TYPE_int); // I JUST DO NOT UNDERSTAMD THIS SHIT
				q = pushSchema(be->mb, q, t);
				q = pushStr(be->mb, q, t->base.name);
				q = pushArgument(be->mb, q, rows->nr);
				be->mvc_var = getDestVar(q);
				stmt *s = stmt_create(be->mvc->sa, st_delete);
				s->op1 = rows;
				s->op4.tval = t;
				s->q = q;
				s->nr = getDestVar(q);
			s = stmt_aggr(be, rows, NULL, NULL, sql_bind_aggr(be->mvc->sa, be->mvc->session->schema, "count", NULL), 1, 0, 1);
			//so mb already contains all instruction pointers, hence would like to return a count of the number of deleted rows. This is why s can be reinitialized.
		return stdelete;

			list_append(l, s);
				
			
		


	

	

rel_updates(mvc* sql, symbol* s):
	This is where the function seems to start understanding the semantics of a delete statement (switch s->token: ... case SQL_DELETE:)
	it takes out the pred_exp associated with s (l = s->data.lval;)
	and finally performs (or prepares?) a delete statement (ret = delete_table(sql, l->h->data.lval, l->h->next->data.sym);)
	finally we add to our relation of interest(select = rel) the value list expression (rel_select_add_exp(sql->sa, select, e);)
	
	
		
	
		
		
	


sql_execute.c:SQLrun
	we have two malblkptr's mc, mb
	and one Instrptr p
	mb is set to Client c->curprg->def and later it is replaced with
	mb = copyMalBlk(c->curprg->def) // locate and inline the query template instruction
	in mb the the stop is 3
	
	mb should have an instructionptr

	this instruction pointer's malblockptr is copied to mc (mc = copyMalBlk(p->blk))
	the original mb is freed (freeMalBlk(mb))

	so mb seems to consist of 3 instructions (mb->stop is 3)
	
	
	One by one each instruction is copied to p (p = GetInstrPtr(mb, i));
	the first instruction pointer has name function name "s0 1"
	
	it sho


	so it seems you start with a malblock mb consisting of a (couple of) instruction(s)
	you pick the first instruction
	you take out the inner blk which is also a MALBLOCK and store a pointer to this inner malblock in mb
	
	we then optimize the query (msg = SQLoptimizeQuery(c, mb);)
	
		At some point we get a sql optimizer in the form of string called a 'pipe' from  getSQLoptimizer.
		This is based on the sql mvc (whatever that is, seems to deal with the sql query and user session)
		we can then finally start to optimize the query (parse the query?) (msg = optimizeMalBlock(c, mb))
			
				
	
