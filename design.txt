server afhandeling van xcommand calls
    sql_scenario.c:SQLparser

client kant van xcommand 
    bijvoorbeeld mapi.c:mapi_setAutocommit

bepaling van MAPI protocol server kant
    mal_mapi.c:doChallenge voor parsen en mal_session.c:MSscheduleClient zet het Client.protocol field gelijk aan protocol

Opmerkingen:
mapi.c/h kent geen protocol verschillen zoals PROTOCOL_9 en PROTOCOL_10/"PROT10".

Via een aanvankelijk mapi xcommand aangeven dat we PROTOCOL_COLUMNAR gebruiken. PROTOCOL_COLUMNAR moet er voor zorgen dat sql_result sets geen tablet results gaat maken maar alleen de bats vasthoud.
De headers moeten

gdb -ex r --args mserver5 --dbpath=devdb  --set "mapi_port=50000"
gdb -ex r --args mserver5 --dbpath=devdb1 --set "mapi_port=50001"

mclient -p 50001
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (20), (10), (NULL), (30);

CREATE REMOTE TABLE rt (i int) ON 'mapi:monetdb://127.0.0.1:50001/devdb1/sys/t1';

SELECT * FROM rt;

this will create the following mal function user.%4 on the local side in sql_gencode.c:_create_relational_remote.

function user.%4():bat[:int];
    X_2:bat[:int] := bat.new(nil:int);
    X_4:str := remote.connect("sys.rt":str, "msql":str);
    remote.put(X_4:str, 15:int);
    X_11:str := remote.put(X_4:str, "user":str);
    X_13:str := remote.put(X_4:str, "l4":str);
    X_15:str := remote.put(X_4:str, "\nproject (\ntable(sys.t1) [ \"t1\".\"i\" as \"rt\".\"i\" ] COUNT \n) [ \"rt\".\"i\" ] REMOTE sys.rt\n":str);
    X_17:str := remote.put(X_4:str, "":str);
    X_19:str := remote.put(X_4:str, "int":str);
    remote.exec(X_4:str, "sql":str, "register":str, X_11:str, X_13:str, X_15:str, X_17:str, X_19:str);
    remote.put(X_4:str, 5:int);
    X_25:str := remote.put(X_4:str, "df7b54d9-da0f-4f38-a40b-10f675da1e7e":str);
    X_27:str := remote.put(X_4:str, "8499eb56-2c5b-4509-97a5-ac4b90d3b309":str);
    remote.exec(X_4:str, "remote":str, "register_supervisor":str, X_25:str, X_27:str);
    remote.register_supervisor("df7b54d9-da0f-4f38-a40b-10f675da1e7e":str, "8499eb56-2c5b-4509-97a5-ac4b90d3b309":str);
    X_30:str := remote.put(X_4:str, X_2:bat[:int]);
    X_30:str := remote.exec(X_4:str, "user":str, "l4":str);
    X_2:bat[:int] := remote.get(X_4:str, X_30:str);
    remote.disconnect(X_4:str);
    return X_2:bat[:int] := X_2:bat[:int];


DESIGN
Xset_protocol PROTOCOL_COLUMNAR
sql_result checkt taal
stuurt header op welke ook de volgorde van opsturen van de BAT's bepaald en stuurt vervolgens de BAT's ook op in die volgorde via de onderliggende mapi stream a la remote.

de client leest de header stream en pakt daarna de onderliggende read stream en vangt daarmee de bats op.


handling monetdbe_prepare

Normale prepare komt in

sql_scenario.c:parser terecht. Daar wordt de PREPARE herkent en daar wordt m(ode) van de mvc
op m_prepare gezet. de sql_parse operatie parst de hele query en maakt een geoptimaliseerd relationeel plan
met place holders. Deze wordt vervolgens in de query cache gestopt via sql_qc.c:qc_insert.
Een id naar de query in de qc wordt teruggegeven en bewaard in de backend van de mvc.

normale exec

#0  rel_nop (query=0x7fffd42c6830, rel=0x7ffff02e1858, se=0x7fffd42c67e0, fs=32772, ek=...)
    at /home/aris/sources/monetdb/sql/server/rel_select.c:3137
#1  0x00007ffff1eacebc in rel_value_exp2 (query=0x7fffd42c6830, rel=0x7ffff02e1858, se=0x7fffd42c67e0, 
    f=32772, ek=...) at /home/aris/sources/monetdb/sql/server/rel_select.c:4923
#2  0x00007ffff1ead4f0 in rel_value_exp (query=0x7fffd42c6830, rel=0x7ffff02e1858, se=0x7fffd42c67e0, 
    f=32772, ek=...) at /home/aris/sources/monetdb/sql/server/rel_select.c:5050
#3  0x00007ffff1f27a6a in rel_psm_call (query=0x7fffd42c6830, se=0x7fffd42c67e0)
    at /home/aris/sources/monetdb/sql/server/rel_psm.c:166
#4  0x00007ffff1f2f5ee in rel_psm (query=0x7fffd42c6830, s=0x7fffd42c6800)
    at /home/aris/sources/monetdb/sql/server/rel_psm.c:1576
#5  0x00007ffff1e91f34 in rel_semantic (query=0x7fffd42c6830, s=0x7fffd42c6800)
    at /home/aris/sources/monetdb/sql/server/rel_semantic.c:198
(gdb) p s->token 
$24 = SQL_CALL
#6  0x00007ffff1d3a754 in sql_symbol2relation (be=0x7fffd4222fc0, sym=0x7fffd42c6800)
    at /home/aris/sources/monetdb/sql/backends/monet5/sql.c:119
#7  0x00007ffff1d5d1b4 in SQLparser (c=0x5555557b51c0)
    at /home/aris/sources/monetdb/sql/backends/monet5/sql_scenario.c:1074
#8  0x00007ffff795d01b in runPhase (c=0x5555557b51c0, phase=1)
    at /home/aris/sources/monetdb/monetdb5/mal/mal_scenario.c:448

mclient doet prepare niet via mapi_prepare maar via een normale mapi_query.
De remote zal dan dit normaal parsen. en geeft in sql_result.c:mvc_export_prepare
de noodzakelijke meta data voor het aanroepen van de prepared statement.
mclient gebruikt 

Plan

Expand sqlStatementIntern to incorporate prepared statements.

use remote to call sql.prepare on the remote side. Remote should return similar info as regular mapi.


function user.%2():any;
    X_0:any := remote.put("_monetdb_0":str, true:bit);
    X_3:any := remote.put("_monetdb_0":str, "SELECT x, y, 1 AS some_int FROM test WHERE x > 10; ":str);
    remote.exec("_monetdb_0":str, "sql":str, "eval":str, 0x7fffffffdba0:ptr, X_3:any, X_0:any);
    return :void;

function user.%2():any;
    X_0:str := remote.put("_monetdb_0":str, true:bit);
    X_3:str := remote.put("_monetdb_0":str, "SELECT x, y, 1 AS some_int FROM test WHERE x > 10; ":str);
    remote.exec("_monetdb_0":str, "sql":str, "eval":str, 0x7fffffffdba0:ptr, X_3:str, X_0:str);
    return :void;
